org	0100h

BASE_STACK	equ	0100h	;原理跟boot.asm里面的一样
BASE_KERNEL	equ	08000h
OFFSET_KERNEL	equ	0h

	jmp	LABEL_START

%include "fat12hdr.inc"

LABEL_START:
	mov	ax, cs
	mov	ds, ax
	mov	es, ax
	mov	ss, ax
	mov	sp, BASE_STACK

	mov	dh, 0
	call	puts

	mov	word [cur_sec], FST_SEC_IN_ROOT_DIR
	xor	ah, ah
	xor	dl, dl
	int	13h
LABEL_SEARCH_IN_ROOT_DIR_BEGIN:
	cmp	word [nr_sec_unread], 0
	jz	LABEL_NOKERNEL
	dec	word [nr_sec_unread]
	mov	ax, BASE_KERNEL
	mov	es, ax
	mov	bx, OFFSET_KERNEL
	mov	ax, [cur_sec]
	mov	cl, 1
	call	read_sec

	mov	si, NAME_KERNEL
	mov	di, OFFSET_KERNEL
	cld
	mov	dx, 10h
LABEL_SEARCH_FOR_KERNELBIN:
	cmp	dx, 0
	jz	LABEL_GOTO_NEXT_SEC_IN_ROOT_DIR
	dec	dx
	mov	cx, 11
LABEL_CMP_FILENAME:
	cmp	cx, 0
	jz	LABEL_FILENAME_FOUND
	dec	cx
	lodsb
	cmp	al, [ex:di]
	jz	LABEL_GOON
	jmp	LABEL_DIFFERENT

LABEL_GOON:
	inc	di
	jmp	LABEL_CMP_FILENAME

LABEL_DIFFERENT:
	and	di, 0FFE0h	;使di指向该条目最开始的地方
	add	di, 20h
	mov	si, NAME_KERNEL
	jmp	LABEL_SEARCH_FOR_KERNELBIN

LABEL_GOTO_NEXT_SEC_IN_ROOT_DIR:
	add	word [cur_sec], 1
	jmp	LABEL_SEARCH_IN_ROOT_DIR_BEGIN

LABEL_NOKERNEL:
	mov	dh, 2
	call	puts
	jmp	$

LABEL_FILENAME_FOUND:
	mov	ax, NR_SEC_IN_ROOT_DIR
	and	di, 0FFE0h

	push	eax
	mov	eax, [es : di + 01Ch]
	mov	dword [KERNEL_SIZE], eax
	pop	ax
	add	di, 01Ah
	mov	cx, word [es : di]
	push	cx
	add	cx, ax
	add	cx, ALL_SEC_FROM_FST_TO_FAT2
	mov	ax, BASE_KERNEL
	mov	es, ax
	mov	bx, OFFSET_KERNEL
	mov	ax, cx

LABEL_GOON_LOADING_KERNEL:
	push	ax
	push	bx
	mov	ah, 0Eh
	mov	al, '.'
	mov	bl, 0Fh
	int	10h
	pop	bx
	pop	ax

	mov	cl, 1
	call	read_sec
	pop	ax
	call	get_next_clu
	cmp	ax, 0FFFh
	jz	LABEL_FILE_LOAD_SUCCESSFULLY
	push	ax
	mov	dx, NR_SEC_IN_ROOT_DIR
	add	ax, dx
	add	ax, ALL_SEC_FROM_FST_TO_FAT2
	add	bx, [BPB_BytsPerSec]
	jmp	LABEL_GOON_LOADING_KERNEL
LABEL_FILE_LOAD_SUCCESSFULLY:
	call	kill_motor

	mov	dh, 1
	call	puts

	jmp	$

;macro
FST_SEC_IN_ROOT_DIR		equ	19
ALL_SEC_FROM_FST_TO_FAT2	equ	19 - 2
;variable
cur_sec		dw	0
nr_sec_unread	dw	14
NAME_KERNEL	db	"KERNEL  BIN"
KERNEL_SIZE	dd	0
